#!/usr/bin/env perl6
use Shell::Command;
use Panda;
use Panda::Ecosystem;
use Panda::App;
use Panda::Mirrors;
use Panda::CPAN;

# default opts for MAIN
if %*ENV<PANDA_DEFAULT_OPTS> {
    @*ARGS = %*ENV<PANDA_DEFAULT_OPTS> ~ (@*ARGS ?? ' ' ~ @*ARGS !! '');
}

# initialize the Panda object
my $panda;
{
    my $pandadir;
    my $destdir = %*ENV<DESTDIR>;
    $destdir = "{cwd}/$destdir" if defined($destdir) &&  $*OS ne 'MSWin32' && $destdir !~~ /^ '/' /;
    for grep(*.defined, $destdir, %*CUSTOM_LIB<site home>) -> $prefix {
        $destdir  = $prefix;
        $pandadir = "$prefix/panda";
        try mkpath $pandadir unless $pandadir.IO ~~ :d;
        last if $pandadir.path.w
    }
    unless $pandadir.path.w {
        die "Found no writable directory into which panda could be installed";
    }

    my $cpan = Panda::CPAN.new( :$pandadir );

    my $mirrors = Panda::Mirrors.new(
        mirrorsfile => "$pandadir/MIRRORED.BY",
        mirrorslist => "$pandadir/mirrors.json",
    );

    $panda = Panda.new(:ecosystem(make-default-ecosystem), :$mirrors, :$cpan);
}
my %failed;

# allow switches after positionals
@*ARGS = @*ARGS.grep(/^ '-'/), @*ARGS.grep(/^ <-[-]>/);

#| Install the specified modules
multi MAIN ('install', *@modules, Bool :$notests, Bool :$nodeps, Bool :$cpan, Bool :$github is copy) {
    $github = True unless $cpan;
    for @modules -> $x {
        $panda.resolve($x, :$notests, :$nodeps, :$cpan, :$github);
        CATCH { when X::Panda { %failed{$x}.push($_) && say $_ } };
    }
}

#| Install dependencies, but don't build the modules themselves
multi MAIN ('installdeps', *@modules, Bool :$notests) {
    for @modules -> $x {
        $panda.resolve($x, :$notests, :action<install-deps-only>);
        CATCH { when X::Panda { %failed{$x}.push($_) && say $_ } };
    }
}

#| List all available modules
multi MAIN ('list', Bool :$installed, Bool :$verbose) {
    listprojects($panda, :$installed, :$verbose);
}

#| Update the module database
multi MAIN ('update', Bool :$cpan, Bool :$github is copy) {
    $github = True unless $cpan;
    $panda.ecosystem.update            if $github;
    $panda.cpan.update($panda, :force) if $cpan;
}

#| Display information about specified modules
multi MAIN ('info', *@modules) {
    projectinfo($panda, @modules);
}

#| Search the name/description
multi MAIN ('search', $pattern, Bool :$cpan, Bool :$github is copy) {
    $github = True unless $cpan;
    search-projects($panda, $pattern, :$cpan, :$github);
}

#| Ping CPAN servers to get nearest neighbours
multi MAIN ('probe-mirrors', $limit = Inf) {
    $panda.mirrors.probe($panda);
}

#| Test and install all known distributions
multi MAIN ('smoke', :$exclude = 'panda') {
    my @exclude = $exclude.split(',');
    my @projects = $panda.ecosystem.project-list;
    for @projects -> $p {
        next if $p ~~ any @exclude;
        @exclude.push: $p;
        try {
            $panda.resolve($p, :action<install>);
            CATCH {
                default { }
            }
        }
    }
}

#| Download and unpack the distribution and then open the directory with your shell.
multi MAIN ('look', *@modules) {
    for @modules -> $x {
        $panda.resolve($x, :notests, :nodeps, :action<look>);
        CATCH { when X::Panda { %failed{$x}.push($_)  && say $_ } };
    }
}

END {
    rm_rf '.panda-work' if '.panda-work'.IO.e;

    for %failed.kv -> $source,$messages {
        FIRST say "\nFailure Summary\n----------------";
        say "$source",("\n\t*$_" for $messages.list);
        LAST exit 1;
    }
    exit 0;
}

# vim: ft=perl6
